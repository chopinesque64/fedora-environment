#+TITLE: Emacs Configuration
#+AUTHOR: Nathanael Gentry
#+EMAIL: ngentry1@liberty.edu
#+OPTIONS: toc:nil num:nil

* Bootstrap
** =use=package
My =init.el= sets up MELPA in the package manager and installs =use-package.el= so all the configuration here works, even on a new install. Here, we make this happen by ensuring packages are installed before we use them.
#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

** Environment
Tell emacs where our linux configuration document lives.
#+begin_src emacs-lisp
  (setq linux-configuration-directory "~/projects/fedora-environment/")
#+end_src

** Private Config
Load the private configuration, setting variables and such.
#+begin_src emacs-lisp
  (load (concat user-emacs-directory "npg-private.el"))
  (require 'npg-private)
#+end_src

** Temp File
Add a temporary customization file.
#+begin_src emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+end_src

* Sensible Defaults
Use HRS's [[https://github.com/hrs/sensible-defaults.el/][sensible-defaults.el]] for common-sense settings.
#+begin_src emacs-lisp
  (require 'url)
  (setq-local sensible-defaults-loc (concat user-emacs-directory "defaults.el"))
  (if (not (file-exists-p sensible-defaults-loc))
      (url-copy-file "https://raw.githubusercontent.com/hrs/sensible-defaults.el/master/sensible-defaults.el" sensible-defaults-loc))

  (load-file sensible-defaults-loc)
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

Perhaps backups would be good to have, but let's not have them clutter our current directory. And let's not do autosave or lockfiles, either. I save frequently enough.
#+begin_src emacs-lisp
  (setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
  (setq auto-save-default nil
        create-lockfiles nil)
#+end_src

** Sensible Functions
Define some sensible utility functions.

#+begin_src emacs-lisp
  (defun npg/append-to-path (path)
    "Append a path to $PATH and exec-path"
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+end_src

#+begin_src emacs-lisp
  (defun npg/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src

#+begin_src emacs-lisp
  (defun npg/disable-line-numbers ()
    "Shortcut function to disable line numbers."
    (setq display-line-numbers-mode -1))
#+end_src

* Custom Functions
** Peek Frame
Tuhdo has an excellent tutorial on setting up popup frames for =rtags=, and I've generalized his code and made the popup undecorated but still resizable.

#+begin_src emacs-lisp
  (defun npg/make-peek-frame (in-frame-function &rest args)
    "Make a new frame for peeking definition"
    (let (summary
          doc-frame
          x y
          ;; Find the pixel absolute position of the current beginning of the symbol at point.
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;; 2. Create a new invisible frame, with the current buffer in it.
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15)
                                    (undecorated . t)
                                    (drag-internal-border . 1)
                                    (internal-border-width . 5))))

      ;; 3. Position the new frame right under the beginning of the symbol at point.
      (set-frame-position doc-frame x y)

      ;; 4. Jump to the symbol at point.
      (with-selected-frame doc-frame
        (apply in-frame-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;; 5. Make frame visible again
      (make-frame-visible doc-frame)))
#+end_src
** Buffer Mode
#+begin_src emacs-lisp
  (defun npg/buffer-mode (&optional buffer-or-name)
    "Returns the major mode associated with a buffer.
  If buffer-or-name is nil return current buffer's mode."
    (buffer-local-value 'major-mode
     (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+end_src

* Appearance
** Window
Reclaim real estate, especially on my old X220T, by disabling window chrome.
#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

Tooltips generally aren't helpful. Let's just display the information in the
minibuffer area instead.
#+begin_src emacs-lisp
  (tooltip-mode -1)
#+end_src

Start Emacs maximized.
#+begin_src emacs-lisp
  (toggle-frame-maximized)
#+end_src

** Theme
I love the unobtrusive elegance of [[https://github.com/arcticicestudio/nord-emacs][nord-emacs]], although sometimes the colors can be a little /too/ subtle.
#+begin_src emacs-lisp
  (use-package nord-theme
    :load-path "themes"
    :config
    (load-theme 'nord t))
#+end_src

Frame transparency does not seem to play nicely with Cinnamon, but here's a function to manipulate it.
#+begin_src emacs-lisp
  (defun opacity (value)
    "Sets the percent opacity of the frame window."
    (interactive "nOpacity Value (0 - 100):")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Modeline
I want a pristine modeline, uncluttered by modetexts. Note that the window title gives =projectile= info.
#+begin_src emacs-lisp
  (use-package minions
    :config
    (setq minions-mode-line-lighter ""
          minions-mode-line-delimiters '("" . ""))
    (minions-mode 1))
#+end_src

Now, let's display 24-hour time in the modeline, but hide the default system
load information.
#+begin_src emacs-lisp
  (setq display-time-default-load-average nil
        display-time-24hr-format t)

  (display-time-mode)
#+end_src

** Default Windows
Split into two windows on startup.
#+begin_src emacs-lisp
  (split-window-right)
#+end_src

* Global Editor
Note that =sensible-defaults.el= already inhibits the startup screen and blanks the scratch buffer.

** Tabs & Indentation
Let's make our shallow tabs into spaces.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src

** Lines
I used to display line numbers globally, but that got to be too much of a pain when I had to picemeal disable numbers for =mu4e=, the agenda, the terminal, and special modes. Now, we just enable line numbers for major programming languages -- those that derive from =prog-mode= -- and all files we open through =find-file=.
#+begin_src emacs-lisp
  (dolist (lines-mode
           '(prog-mode-hook
             find-file-hook))
    (add-hook lines-mode #'display-line-numbers-mode))
#+end_src

Also show column numbers in the modeline.
#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

Who needs to split lines at 80 characters?
#+begin_src emacs-lisp
  (global-visual-line-mode)
#+end_src

** =smartparens=
So powerful.
#+begin_src emacs-lisp
(use-package smartparens
  :bind (:map smartparens-mode-map
         ("C-M-f" . sp-next-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-a" . sp-backward-down-sexp)
         ("C-M-u" . sp-up-sexp)
         ("C-M-e" . sp-backward-up-sexp)
         ("C-M-n" . sp-forward-sexp)
         ("C-M-p" . sp-previous-sexp)
         ("C-S-d" . sp-beginning-of-sexp)
         ("C-S-a" . sp-end-of-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         ("M-<delete>" . sp-unwrap-sexp)
         ("M-<backspace>" . sp-backward-unwrap-sexp)
         ("M-D" . sp-splice-sexp)
         ("C-S-<backspace>" . sp-splice-sexp-killing-around)
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-<left>" . sp-forward-barf-sexp)
         ("C-S-<left>" . sp-backward-slurp-sexp)
         ("C-S-<right>" . sp-backward-barf-sexp))
  :init
  (setq sp-cancel-autoskip-on-backward-movement nil)
  :config
(require 'smartparens-config))
#+end_src

** =rainbow-delimiters=
I am not yet an Emacs minimalist.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

** =ido=
Very basic for now.

#+begin_src emacs-lisp
  (ido-mode 'both)
  (setq ido-enable-flex-matching t)

  ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)

  ; Use the current window for indirect buffer display
  (setq org-indirect-buffer-display 'current-window)
#+end_src

** =company=
Enable =company= everywhere, and reward our laziness by giving ourselves access to unicode math.
#+begin_src emacs-lisp
  (use-package company
    :ensure company-math
    :init (global-company-mode 1)
    :config (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src

Bind =M-/= to bring up a completion menu.
#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

Quickhelp is useful for API discovery, but it doesn't talk to =nord-theme= right now.
#+begin_src emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode))
#+end_src

** =flycheck=
We'll add local mode hooks for flycheck.
#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

** Keybindings
Quickly open my Emacs and Fedora configuration org documents.
#+begin_src emacs-lisp
  (defun npg/visit-emacs-config ()
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (global-set-key (kbd "C-c e e") 'npg/visit-emacs-config)
#+end_src

#+begin_src emacs-lisp
  (defun npg/visit-linux-config ()
    (interactive)
    (find-file (concat linux-configuration-directory "fedora-environment.org")))

    (global-set-key (kbd "C-c e f") 'npg/visit-linux-config)
#+end_src

Always kill the current buffer with keystroke.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'npg/kill-current-buffer)
#+end_src

When splitting a window, I always want focus in the new window.
#+BEGIN_SRC emacs-lisp
  (defun nps/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun npg/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'npg/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'npg/split-window-right-and-switch)
#+END_SRC

* Completion
** Ivy
I will try out Ivy for now, but I'm not against moving to Helm. We use
=counsel-M-x= for command completion, replace =isearch= with =swiper=, and use
fuzzy matching everywhere except swiper. (Only exact matches make sense there.)

I prefer the =ido= way of doing things for finding files, so I don't use =counsel-find-file=.

#+begin_src emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :init
    (ivy-mode 1)
    (use-package flx)

    (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d)"
          ivy-initial-inputs-alist nil
          ivy-re-builders-alist
            '((swiper . ivy--regex-plus)
              (t . ivy--regex-fuzzy))))
#+end_src

** Avy
Since I'm trying to stay away from =evil= for now, Avy sounds like it might be
useful. Let's try it out.
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-s" . avy-goto-word-1)))
#+end_src

* Project Management
** =ag=
Try out the Silver Searcher.
#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =magit=
Nothing special to see here.
#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (setq magit-completing-read-function 'magit-ido-completing-read))
#+end_src

** =projectile=
Search for files within a project with =projectile-ag= through =C-c v=. Also
bind =C-p= to fuzzy-searching within a project, and use the current directory as
a project root when we don't have a defined project. This enables
fuzzy-searching for files anywhere.
   #+begin_src emacs-lisp
     (use-package projectile
       :bind
       ("C-c v" . 'projectile-ag)
       ("C-p" . 'projectile-find-file)

       :config
       (setq projectile-completion-system 'ivy
             projectile-switch-project-action 'projectile-dired
             projectile-require-project-root nil))
   #+end_src

Perhaps Sr. Speedbar is better, but let's try this for now.
#+begin_src emacs-lisp
  (use-package project-explorer
    :bind ("C-x p" . project-explorer-open))
#+end_src

** =dumb-jump=
And to think of the untold hours I spent configuring C\C++ tags when I could have used this!
#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (global-set-key (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+end_src

* Development Environments
** Python
Set up our =virtualenv= for =jedi=.
#+begin_src emacs-lisp
  (npg/append-to-path "~/.local/bin")
#+end_src

Use =elpy= for a great IDE experience.
#+begin_src emacs-lisp
  (use-package elpy
    :init (elpy-enable))
#+end_src

Check syntax with =flycheck=.
#+begin_src emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+end_src

Format code by PEP8 on save.
#+begin_src emacs-lisp
  (use-package py-autopep8
  :init (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src

(Do we need to use company-jedi since we already have elpy?)

** C/C++
Maybe =rtags= is a bit intense, but using it with =cmake-ide= works well now.
#+begin_src emacs-lisp
  (use-package rtags
    :ensure flycheck-rtags
    :init
    (add-hook 'c-mode-common-hook (lambda ()
                                   (flycheck-select-checker 'rtags)
                                   (setq-local flycheck-highlighting-mode nil)
                                   (setq-local flycheck-check-syntax-automatically nil)))

    (setq rtags-autostart-diagnostics t
          rtags-completions-enabled t)
    (push 'company-rtags company-backends))
#+end_src

Use =cmake-ide= to automate =rtags= processes in a CMake project.
#+begin_src emacs-lisp
  (use-package cmake-ide
    :init (cmake-ide-setup))
#+end_src

** LaTeX
Org will begin replacing pure LaTeX for notes and such, but I still complete homework in here.
First, set up =pdf-tools= for full previews, and disable line numbers in PDF buffers.
#+begin_src emacs-lisp
  (use-package pdf-tools
  :bind
  ("C-c C-g" . pdf-sync-forward-search)

  :init
  (pdf-tools-install)
  (setq mouse-wheel-follow-mouse t
        pdf-view-resize-factor 1.00)
  (add-hook 'pdf-view-mode-hook
            (npg/disable-line-numbers)))
#+end_src

Now, we can setup LaTeX. I don't bother setting up RefTeX because I write papers in Org.
Note, however, that Org also uses these settings to show PDF previews.
#+begin_src emacs-lisp
(use-package tex-site
    :ensure auctex
    :init
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-source-correlate-method 'synctex
          TeX-correlate-start-server t
          TeX-view-program-selection '((output-pdf "pdf-tools"))
          TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
    (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
              #'TeX-revert-document-buffer))
#+end_src

** JSON
=json-mode= works well for all I need, and I have a custom yasnippet for Org. We can pretty-print with =C-c C-f=.
#+begin_src emacs-lisp
  (use-package json-mode)
#+end_src

** Prose
*** =flyspell=
Let's enable spell-checking for text (org, markdown) and commit messages.
#+begin_src emacs-lisp
    (use-package flyspell
      :config
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (add-hook 'gfm-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'git-commit-mode-hook 'flyspell-mode))
#+end_src

*** Dictionary: Webster 1913
I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.
#+begin_src emacs-lisp
    (defun hrs/dictionary-prompt ()
      (read-string
       (format "Word (%s): " (or (hrs/region-or-word) ""))
       nil
       nil
       (hrs/region-or-word)))

    (defun hrs/dictionary-define-word ()
      (interactive)
      (let* ((word (hrs/dictionary-prompt))
             (buffer-name (concat "Definition: " word)))
        (with-output-to-temp-buffer buffer-name
          (shell-command (format "sdcv -n %s" word) buffer-name))))

    (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
#+end_src

*** Thesaurus: WordNet
Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-x s= searches for synonyms.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus)
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
  (define-key global-map "\C-xs" 'synosaurus-lookup)
#+END_SRC

*** Word Count
This little [[https://www.emacswiki.org/emacs/wcMode][minor mode]] sets =mode-line-position= to display character count,
word count, and line count.
#+begin_src emacs-lisp
      (setq mode-line-position
        (append
         mode-line-position
         '((wc-mode
      (6 (:eval (if (use-region-p)
        (format " %d,%d,%d"
          (abs (- (point) (mark)))
          (count-words-region (point) (mark))
          (abs (- (line-number-at-pos (point))
            (line-number-at-pos (mark)))))
            (format " %d,%d,%d"
              (- (point-max) (point-min))
              (count-words-region (point-min) (point-max))
              (line-number-at-pos (point-max))))))
      nil))))
#+end_src

* Terminal
Use =multi-term= for login shell sessions.
#+begin_src emacs-lisp
  (use-package multi-term
    :init
    (global-set-key (kbd "C-c t") 'multi-term)
    (setq multi-term-program-switches "--login"))
#+end_src

* Org
** Installation
 We have already installed the Org package archive, so let's ensure we're using that latest released version with contributions.
 #+begin_src emacs-lisp
   (use-package org
     :ensure org-plus-contrib)
 #+end_src

** Keybindings
Let's add these sensible keybindings.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
#+end_src

Open source block editor (=C-c '=) in a split window; make formats and tabs native.
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'split-window-below)
#+end_src

** Defaults
*** Editor
Indent headings by default, and use =yasnippet=.
#+begin_src emacs-lisp
  (dolist (mode-hook
                   '(org-indent-mode
                     yas-minor-mode))
            (add-hook 'org-mode-hook mode-hook))
#+end_src

Make sure we have LaTeX snippets available in Org mode.
#+begin_src emacs-lisp
  (yas-activate-extra-mode 'latex-mode)
#+end_src

Let's use =ido= in here.
#+begin_src emacs-lisp
  (setq org-completion-use-ido t)
#+end_src

*** Display
Since =nord-theme= doesn't have good heading contrast, use bullet heading indicators.
#+begin_src emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

And change from the distracting default ellipsis.
#+begin_src emacs-lisp
  (setq org-ellipsis " ▼ ")
#+end_src

Let's set =org-column-view= to emphasize timekeeping.
#+begin_src emacs-lisp
  (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
#+end_src

** Export
*** Oxen
Allow export to markdown and beamer (for presentations).
#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

*** Babel
Don't ask before evaluating code blocks.
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Python, shell, dot, or Gnuplot code.
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Allow editing JSON.
#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("json" . json))
#+end_src

*** HTML
Make sure we have the latest version of =htmlize= installed by default.
#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.
#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setq proess-connection-type nil)
#+END_SRC

** Paths
Store my org files in =~/documents/org=.
#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun npg/org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-index-file (npg/org-file-path "index.org")
        org-jot-file (npg/org-file-path "jot.org")
        org-journal-file (npg/org-file-path "journal.org")
        org-archive-location (concat (npg/org-file-path "archive.org") "::*%s"))
#+end_src

 Derive the agenda from =index.org=, the project index.
#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+end_src

** Tasks
*** States
I am using these [[http://doc.norang.ca/org-mode.html][task states]], with some verbiage modification. A task should be
in state =WAIT= when the task needs information from someone else; it should be
set to =HOLD= when I don't have time to do it. Note that states =WAIT=,
=HOLD=, and =DROP= request a note upon state shift.
#+begin_src emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|" "DROP(c@/!)" "MEET"))))
#+end_src

#+begin_src emacs-lisp
  (setq org-todo-keyword-faces
        '(("TODO" :foreground "light salmon" :weight bold)
        ("NEXT" :foreground "SteelBlue1" :weight bold)
        ("DONE" :foreground "light green" :weight bold)
        ("WAIT" :foreground "MediumOrchid1" :weight bold)
        ("HOLD" :foreground "Orchid1" :weight bold)
        ("DROP" :foreground "VioletRed1" :weight bold)
        ("MEET" :foreground "light green" :weight bold)))

#+end_src

Since we have defined keys for each state, we can use fast selection with =C-c C-t KEY=.
#+begin_src emacs-lisp
  (setq org-use-fast-todo-selection t)
#+end_src

Using =S-<arrow=, easily change task states without all the processing (e.g. setting timestamps and notes) of normal state cycling. Useful for fixing the status of an entry.
#+begin_src emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

*** Tag Integration
To aid agenda filtering, auto-update tags whenever the state changes.
#+begin_src emacs-lisp
   (setq org-todo-state-tags-triggers
        (quote (("DROP" ("DROP" . t))
                ("WAIT" ("WAIT" . t))
                ("HOLD" ("WAIT") ("HOLD" . t))
                (done ("WAIT") ("HOLD"))
                ("TODO" ("WAIT") ("DROP") ("HOLD"))
                ("NEXT" ("WAIT") ("DROP") ("HOLD"))
                ("DONE" ("WAIT") ("DROP") ("HOLD")))))
#+end_src

*** Archive
Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.
#+BEGIN_SRC emacs-lisp
  (defun npg/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'npg/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

** Tags
Note that the =@= group, which contains location tags, functions like a bank of
radio buttons: selecting one location will deselect another selection within the
group. Note that some of the non-exclusive tags are applied by the task state changers.
#+begin_src emacs-lisp
  (setq org-tag-alist '(((:startgroup)
                          ("@errand" . ?e)
                          ("@campus" . ?c)
                          ("@home" . ?H)
                          ("@office" . o)
                          (:endgroup)
                          ("DROP" . ?d)
                          ("WAIT" . ?w)
                          ("HOLD" . ?h)
                          ("PERS" . ?P)
                          ("SYS" . ?S)
                          ("LIBRTY" . ?l)
                          ("RSCH" . ?r)
                          ("MUSC" . ?m))))
#+end_src

Since we have defined single keys for tag application, let's use them.
#+begin_src emacs-lisp
  (setq org-fast-tag-selection-single-key (quote expert))
#+end_src

** Projects
Here are some helper functions, from [[http://doc.norang.ca/org-mode.html#Projects][norang]], that the agenda uses for project
display. These assume a lazy project definition: any task with a subtask is a
project. Note also that stuck projects are those that do not have a subtask with
the =NEXT= designation.
#+begin_src emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-non-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-task-p)
          nil)
         (t
          next-headline)))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))
#+end_src

#+RESULTS:
: bh/find-project-task

** Capture
Let's bind =org-capture= to something sensible.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

Define a few common tasks as capture templates.
#+begin_src emacs-lisp
  (setq org-capture-templates
        ;; todo
        '(("t" "todo" entry (file+headline org-index-file "INBOX")
           "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)

          ;; email answer (auto)
          ("e" "email" entry (file+headline org-index-file "INBOX")
           "* NEXT Answer %:from on %:subject\nSCHEDULED: %t\n%U\n%a\n"
           :clock-in t :clock-resume t :immediate-finish t)

          ;; web bookmark
          ("b" "webmark" entry (file+headline org-jot-file "Webmarks")
           "* %?\n:PROPERTIES:\n:CREATED: %U\n :END:\n\n" :empty-lines 1)

          ;; meeting
          ("m" "meeting" entry (file+headline org-index-file "INBOX")
           "* MEETING: %? :MEETING:\n%U" :clock-in t :clock-resume t)

          ;; journal entry
          ("j" "Journal" entry (file+datetree org-journal-file)
           "* %?\n%U\n" :clock-in t :clock-resume t)))
#+end_src

Define some custom actions to take on completion or termination of a capture.
Right now, this just automatically marks for refile any message on which we
successfully complete a capture.
#+begin_src emacs-lisp
  (defun npg/org-capture-after-finalize ()
    (if org-note-abort ()
      (if (equal (npg/buffer-mode) 'mu4e-headers-mode)
           (mu4e-headers-mark-for-refile)
         (if (equal (npg/buffer-mode) 'mu4e-view-mode)
             (mu4e-view-mark-for-refile)))))

  (add-hook 'org-capture-after-finalize-hook 'npg/org-capture-after-finalize)
#+end_src

** Refile
We can refile into the current file and the index file, up to 3 levels deep.
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 3)
                             (org-agenda-file :maxlevel . 3)))
#+end_src

Use full outline paths for refile targets, so ido works well.
#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow =refile= to create parent nodes with confirmation.
#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

** Archive
Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.
#+BEGIN_SRC emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC
#+begin_src emacs-lisp
#+end_src


#+end_src

* Email
** Installation
I will connect =mu4e= to =offlineimap=, which I install in my environment documentation.
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
  (require 'mu4e)
#+end_src

I like to think of my mail as living in a Postoffice rather than a Maildir. Perhaps it's just the Brit in me.
#+begin_src emacs-lisp
  (setq mu4e-maildir "~/postoffice")
#+end_src

By officially registering =mu4e= here, we can start a message with =C-x m=.
#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Rather than installing an =offlineimap= timer in =systemctl=, let's have =mu4e= call one-off updates for us by its own timer. I haven't yet investigated the relative performance implications.
#+begin_src emacs-lisp
    (setq mu4e-get-mail-command "offlineimap -o"
          mu4e-update-interval 3600)
#+end_src

Don't ask us about quitting =mu4e=.
#+begin_src emacs-lisp
  (setq mu4e-confirm-quit nil)
#+end_src

** Contexts
See the [[file:~/.offlineimaprc][OfflineIMAP Config]] for inbound mail.

We send all messages by SMTP.
#+begin_src emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src

*** Gmail
#+begin_src emacs-lisp
  (let ((gmail-setup-vars '((smtpmail-smtp-server   . "smtp.gmail.com")
                            (smtpmail-stream-type   . starttls)
                            (smtpmail-smtp-service  .  587)
                            (mu4e-maildir-shortcuts . (("/Gmail/INBOX" . ?i)
                                                       ("/Gmail/[Gmail].Sent Mail"   . ?s)
                                                       ("/Gmail/[Gmail].Trash"       . ?t)))))
        (gmail-prefix "[Gmail].")
        (gmail-sent-folder "Sent Mail")
        (gmail-trash-folder "Trash")
        (gmail-drafts-folder "Drafts"))

      (make-mu4e-context-account
       :name "Gmail"
       :user-mail-address npg/gmail-address
       :sent-folder (concat gmail-prefix gmail-sent-folder)
       :trash-folder (concat gmail-prefix gmail-trash-folder)
       :drafts-folder (concat gmail-prefix gmail-drafts-folder)
       :vars gmail-setup-vars))
#+end_src

*** Exchange
#+begin_src emacs-lisp
  (let ((exchange-setup-vars '((smtpmail-smtp-server  . "localhost")
                               (smtpmail-smtp-service . 1025)
                               (smtpmail-stream-type  . network)
                               (mu4e-maildir-shortcuts . (("/Exchange/INBOX" . ?i)
                                                          ("/Exchange/Sent" . ?s)
                                                          ("/Exchange/Trash" . ?t)))))
        (exchange-sent-folder "Sent")
        (exchange-trash-folder "Trash")
        (exchange-refile-folder "Archive")
        (exchange-drafts-folder "Drafts"))

      (make-mu4e-context-account
       :name "Exchange"
       :user-mail-address npg/exchange-address
       :sent-folder exchange-sent-folder
       :trash-folder exchange-trash-folder
       :drafts-folder exchange-drafts-folder
       :refile-folder exchange-refile-folder
       :vars exchange-setup-vars))
#+end_src

** Headers
Open the Exchange inbox with =C-c m=.
#+begin_src emacs-lisp
    (defun npg/visit-inbox ()
      (interactive)
      (mu4e~headers-jump-to-maildir "/Exchange/INBOX"))

    (global-set-key (kbd "C-c m") 'npg/visit-inbox)
#+end_src

Only move messages to the trash folder; do not mark them as deleted.
In other words, do not add =+T= before =-N= so message is not marked IMAP-deleted. See [[https://github.com/djcb/mu/issues/1136][mu #1136]].
#+begin_src emacs-lisp
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target) "-N"))))
#+end_src

Optimize display for split window; do not reproduce the subject line within threads.
#+begin_src emacs-lisp
  (setq mu4e-headers-fields
      '( (:human-date     .  25)
         (:flags          .   4)
         (:from           .  22)
         (:thread-subject .  nil)))
#+end_src

Inside the header view, refresh with =o=.
#+begin_src emacs-lisp
    (define-key mu4e-headers-mode-map (kbd "o") 'mu4e-update-mail-and-index)
#+end_src

Quit =mu4e= immediately from header view with =z=.
#+begin_src emacs-lisp
  (define-key mu4e-headers-mode-map (kbd "z") 'mu4e-quit)
#+end_src

** Composition
Auto-fill mode, which automatically inserts hard linebreaks, is quite unhelpful for messages that will be seen on other clients. Let's use soft breaks instead, so we don't drive our non-Emacs friends crazy.
#+begin_src emacs-lisp
  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                 (auto-fill-mode -1)
                                 (visual-line-mode)))
#+end_src

When I'm composing a new email, default to using the first context.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+END_SRC

Enable Org-style tables and list manipulation.
#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

Once I've sent a message, kill the associated buffer instead of just burying it.
#+BEGIN_SRC emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+END_SRC

** Replies
So replies quote correctly on other clients, change the reply header string to imitate Gmail.
#+begin_src emacs-lisp
  (defun npg/message-insert-compatible-citation-line ()
    "Based off `message-insert-citation-line`."
    (when message-reply-headers
      (insert "On " (mail-header-date message-reply-headers) " ")
      (insert (mail-header-from message-reply-headers) " wrote...")
      (newline)
      (newline)))

  (setq message-citation-line-function 'npg/message-insert-compatible-citation-line)
#+end_src

** Reader
Display the sender's email address along with their name.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-view-show-addresses t)
#+END_SRC

While HTML emails are undeniably sinful, we often have to read them. That's
sometimes best done in a browser. This effectively binds =a h= to open the
current email in my default Web browser.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-view-actions '("html in browser" . mu4e-action-view-in-browser) t)
#+END_SRC

** Signatures
These are my plain-text email signatures.
#+begin_src emacs-lisp
    (defvar npg/email-signatures)
    (setq npg/email-signatures '(("formal" . (concat
                                              "Nathanael Gentry\n"
                                              "Mathematics, Liberty University\n"
                                              "Class of 2021\n"))
                                 ("personal" . "Nathanael Gentry\n")))
#+end_src

Thanks to Rob Stewart for the =mu4e-read-option= idea.
#+begin_src emacs-lisp
    (defun npg/mu4e-choose-signature ()
      "Insert one of a number of sigs"
      (interactive)
      (let ((message-signature
             (mu4e-read-option "Signature:"
                               npg/email-signatures)))
        (message-insert-signature)))

    (add-hook 'mu4e-compose-mode-hook
              (lambda () (local-set-key (kbd "C-c C-w") #'npg/mu4e-choose-signature)))
#+end_src

** Notifications
We use the =mu4e-alert= package to give modeline mail alerts.
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init
    (setq mu4e-alert-interesting-mail-query
          (concat
           "flag:unread maildir:/Exchange/INBOX "
           "OR "
           "flag:unread maildir:/Gmail/INBOX"))
    (mu4e-alert-enable-mode-line-display)

    (defun npg/refresh-mu4e-alert-mode-line ()
      (interactive)
      (mu4e-alert-enable-mode-line-display))

    (run-with-timer 0 3600 'npg/refresh-mu4e-alert-mode-line))
#+end_src

** Org
If we capture a todo while in =mu4e= header mode, store a link to the message itself, not the header query.

As noted at [[http://pragmaticemacs.com/emacs/master-your-inbox-with-mu4e-and-org-mode/][Pragmatic Emacs]], this allows creating a todo for messages that need action, and then archiving it since it no longer needs to stay in the inbox -- we have a direct link to it in the todo.
#+begin_src emacs-lisp
  (require 'org-mu4e)
  (setq org-mu4e-link-query-in-headers-mode nil)
#+end_src

