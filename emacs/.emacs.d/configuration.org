#+TITLE: Emacs Configuration
#+AUTHOR: Nathanael Gentry
#+EMAIL: ngentry1@liberty.edu
#+OPTIONS: toc:nil num:nil
#+PROPERTY: header-args :results output silent

* Bootstrap
** =use-package=
My =init.el= sets up MELPA in the package manager and installs =use-package.el= so all the configuration here works, even on a new install. Here, we make this happen by ensuring packages are installed before we use them.
#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

** Environment
Tell emacs where our linux configuration document lives.
#+begin_src emacs-lisp
  (setq linux-configuration-directory "~/projects/fedora-environment/")
#+end_src

** Private Config
Load the private configuration, setting variables and such.
#+begin_src emacs-lisp
  (load (concat user-emacs-directory "npg-private.el"))
  (require 'npg-private)
#+end_src

** Temp File
Add a temporary customization file.
#+begin_src emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+end_src

* Sensible Defaults
Use HRS's [[https://github.com/hrs/sensible-defaults.el/][sensible-defaults.el]] for common-sense settings.
#+begin_src emacs-lisp
  (require 'url)
  (setq-local sensible-defaults-loc (concat user-emacs-directory "defaults.el"))
  (if (not (file-exists-p sensible-defaults-loc))
      (url-copy-file "https://raw.githubusercontent.com/hrs/sensible-defaults.el/master/sensible-defaults.el" sensible-defaults-loc))

  (load-file sensible-defaults-loc)
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

Perhaps backups would be good to have, but let's not have them clutter our current directory. And let's not do autosave or lockfiles, either. I save frequently enough.
#+begin_src emacs-lisp
  (setq backup-directory-alist '(("" . "~/.emacs.d/backup")))
  (setq auto-save-default nil
        create-lockfiles nil)
#+end_src

** Sensible Functions
Define some sensible utility functions.

#+begin_src emacs-lisp
  (defun npg/append-to-path (path)
    "Append a path to $PATH and exec-path"
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+end_src

#+begin_src emacs-lisp
  (defun npg/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src

#+begin_src emacs-lisp
  (defun npg/disable-line-numbers ()
    "Shortcut function to disable line numbers."
    (setq display-line-numbers-mode -1))
#+end_src

* Custom Functions
** Peek Frame
Tuhdo has an excellent tutorial on setting up popup frames for =rtags=, and I've generalized his code and made the popup undecorated but still resizable.

#+begin_src emacs-lisp
  (defun npg/make-peek-frame (in-frame-function &rest args)
    "Make a new frame for peeking definition"
    (let (summary
          doc-frame
          x y
          ;; Find the pixel absolute position of the current beginning of the symbol at point.
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;; 2. Create a new invisible frame, with the current buffer in it.
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15)
                                    (undecorated . t)
                                    (drag-internal-border . 1)
                                    (internal-border-width . 5))))

      ;; 3. Position the new frame right under the beginning of the symbol at point.
      (set-frame-position doc-frame x y)

      ;; 4. Jump to the symbol at point.
      (with-selected-frame doc-frame
        (apply in-frame-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;; 5. Make frame visible again
      (make-frame-visible doc-frame)))
#+end_src
** Buffer Mode
#+begin_src emacs-lisp
  (defun npg/buffer-mode (&optional buffer-or-name)
    "Returns the major mode associated with a buffer.
  If buffer-or-name is nil return current buffer's mode."
    (buffer-local-value 'major-mode
     (if buffer-or-name (get-buffer buffer-or-name) (current-buffer))))
#+end_src

* Appearance
** Window
Reclaim real estate, especially on my old X220T, by disabling window chrome.
#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

Tooltips generally aren't helpful. Let's just display the information in the
minibuffer area instead.
#+begin_src emacs-lisp
  (tooltip-mode -1)
#+end_src

Start Emacs maximized.
#+begin_src emacs-lisp
  (toggle-frame-maximized)
#+end_src

** Theme
I love the unobtrusive elegance of [[https://github.com/arcticicestudio/nord-emacs][nord-emacs]], although sometimes the colors can be a little /too/ subtle.
#+begin_src emacs-lisp
  (use-package nord-theme
    :load-path "themes"
    :config
    (load-theme 'nord t))
#+end_src

Frame transparency does not seem to play nicely with Cinnamon, but here's a function to manipulate it.
#+begin_src emacs-lisp
  (defun opacity (value)
    "Sets the percent opacity of the frame window."
    (interactive "nOpacity Value (0 - 100):")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Modeline
I want a pristine modeline, uncluttered by modetexts. Note that the window title gives =projectile= info.
#+begin_src emacs-lisp
  (use-package minions
    :config
    (setq minions-mode-line-lighter ""
          minions-mode-line-delimiters '("" . ""))
    (minions-mode 1))
#+end_src

Now, let's display 24-hour time in the modeline, but hide the default system
load information.
#+begin_src emacs-lisp
  (setq display-time-default-load-average nil
        display-time-24hr-format t)

  (display-time-mode)
#+end_src

** Default Windows
Split into two windows on startup.
#+begin_src emacs-lisp
  (split-window-right)
#+end_src

* Global Editor
Note that =sensible-defaults.el= already inhibits the startup screen and blanks the scratch buffer.

** Tabs & Indentation
Let's make our shallow tabs into spaces.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src

** Lines
I used to display line numbers globally, but that got to be too much of a pain when I had to picemeal disable numbers for =mu4e=, the agenda, the terminal, and special modes. Now, we just enable line numbers for major programming languages -- those that derive from =prog-mode= -- and all files we open through =find-file=.
#+begin_src emacs-lisp
  (dolist (lines-mode
           '(prog-mode-hook
             find-file-hook))
    (add-hook lines-mode #'display-line-numbers-mode))
#+end_src

Also show column numbers in the modeline.
#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

Who needs to split lines at 80 characters?
#+begin_src emacs-lisp
  (global-visual-line-mode)
#+end_src

** =smartparens=
So powerful.
#+begin_src emacs-lisp
(use-package smartparens
  :bind (:map smartparens-mode-map
         ("C-M-f" . sp-next-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-a" . sp-backward-down-sexp)
         ("C-M-u" . sp-up-sexp)
         ("C-M-e" . sp-backward-up-sexp)
         ("C-M-n" . sp-forward-sexp)
         ("C-M-p" . sp-previous-sexp)
         ("C-S-d" . sp-beginning-of-sexp)
         ("C-S-a" . sp-end-of-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         ("M-<delete>" . sp-unwrap-sexp)
         ("M-<backspace>" . sp-backward-unwrap-sexp)
         ("M-D" . sp-splice-sexp)
         ("C-S-<backspace>" . sp-splice-sexp-killing-around)
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-<left>" . sp-forward-barf-sexp)
         ("C-S-<left>" . sp-backward-slurp-sexp)
         ("C-S-<right>" . sp-backward-barf-sexp))
  :init
  (setq sp-cancel-autoskip-on-backward-movement nil)
  :config
(require 'smartparens-config))
#+end_src

** =rainbow-delimiters=
I am not yet an Emacs minimalist.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

** =ido=
Very basic for now.

#+begin_src emacs-lisp
  (ido-mode 'both)
  (setq ido-enable-flex-matching t)

  ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)

  ; Use the current window for indirect buffer display
  (setq org-indirect-buffer-display 'current-window)
#+end_src

** =company=
Enable =company= everywhere, and reward our laziness by giving ourselves access to unicode math.
#+begin_src emacs-lisp
  (use-package company
    :ensure company-math
    :init (global-company-mode 1)
    :config (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src

Bind =M-/= to bring up a completion menu.
#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

Quickhelp is useful for API discovery, but it doesn't talk to =nord-theme= right now.
#+begin_src emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode))
#+end_src

** =flycheck=
We'll add local mode hooks for flycheck.
#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

** Keybindings
Quickly open my Emacs and Fedora configuration org documents.
#+begin_src emacs-lisp
  (defun npg/visit-emacs-config ()
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (global-set-key (kbd "C-c e e") 'npg/visit-emacs-config)
#+end_src

#+begin_src emacs-lisp
  (defun npg/visit-linux-config ()
    (interactive)
    (find-file (concat linux-configuration-directory "fedora-environment.org")))

    (global-set-key (kbd "C-c e f") 'npg/visit-linux-config)
#+end_src

Always kill the current buffer with keystroke.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'npg/kill-current-buffer)
#+end_src

When splitting a window, I always want focus in the new window.
#+BEGIN_SRC emacs-lisp
  (defun nps/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun npg/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'npg/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'npg/split-window-right-and-switch)
#+END_SRC

* Interfaces
** =evil=
Use =evil=.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode 1))
#+END_SRC

Enable =surround= everywhere.
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+END_SRC

** Ivy
I will try out Ivy for now, but I'm not against moving to Helm. We use
=counsel-M-x= for command completion, replace =isearch= with =swiper=, and use
fuzzy matching everywhere except swiper. (Only exact matches make sense there.)

I prefer the =ido= way of doing things for finding files, so I don't use =counsel-find-file=.

#+begin_src emacs-lisp
  (use-package counsel
    :bind
    ("M-x" . 'counsel-M-x)
    ("C-s" . 'swiper)

    :init
    (ivy-mode 1)
    (use-package flx)

    (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d)"
          ivy-initial-inputs-alist nil
          ivy-re-builders-alist
            '((swiper . ivy--regex-plus)
              (t . ivy--regex-fuzzy))))
#+end_src

** Avy
Since I'm trying to stay away from =evil= for now, Avy sounds like it might be
useful. Let's try it out.
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-s" . avy-goto-word-1)))
#+end_src

* Project Management
** =dumb-jump=
And to think of the untold hours I spent configuring C\C++ tags when I could have used this!
#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (define-key evil-normal-state-map (kbd "M-.") 'dumb-jump-go)
    (setq dumb-jump-selector 'ivy))
#+end_src

** =ag=
Try out the Silver Searcher.
#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =magit=
I use =magit= to handle version control. It's lovely, but I tweak a few things:

- I bring up the status menu with =C-x g=.
- Use =evil= keybindings with =magit=.
- The default behavior of =magit= is to ask before pushing. I haven't had any
  problems with accidentally pushing, so I'd rather not confirm that every time.
- Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
  beyond 50 characters.
- On the command line I'll generally push a new branch with a plain old =git
  push=, which automatically creates a tracking branch on (usually) =origin=.
  Magit, by default, wants me to manually specify an upstream branch. This binds
  =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
  -v=. Convenient!
- I'd like to start in the insert state when writing a commit message.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (use-package evil-magit)
    (use-package with-editor)
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)

    (with-eval-after-load 'magit-remote
      (magit-define-popup-action 'magit-push-popup ?P
        'magit-push-implicitly--desc
        'magit-push-implicitly ?p t))

    (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

** =projectile=
Search for files within a project with =projectile-ag= through =C-c v=. Also
bind =C-p= to fuzzy-searching within a project, and use the current directory as
a project root when we don't have a defined project. This enables
fuzzy-searching for files anywhere.
#+begin_src emacs-lisp
  (use-package projectile
    :bind
    ("C-c v" . 'projectile-ag)

    :config
    (define-key evil-normal-state-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion ag-mode-map (kbd "C-p") 'projectile-find-file)
    (evil-define-key 'motion rspec-mode-map (kbd "C-p") 'projectile-find-file)

    (setq projectile-completion-system 'ivy
          projectile-switch-project-action 'projectile-dired
          projectile-require-project-root nil))
   #+end_src

* Development Environments
** Python
Set up our =virtualenv= for =jedi=.
#+begin_src emacs-lisp
  (npg/append-to-path "~/.local/bin")
#+end_src

Use =elpy= for a great IDE experience.
#+begin_src emacs-lisp
  (use-package elpy
    :init (elpy-enable))
#+end_src

Check syntax with =flycheck=.
#+begin_src emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+end_src

Format code by PEP8 on save.
#+begin_src emacs-lisp
  (use-package py-autopep8
  :init (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src

(Do we need to use company-jedi since we already have elpy?)

** C/C++
Maybe =rtags= is a bit intense, but using it with =cmake-ide= works well now.
#+begin_src emacs-lisp
  (use-package rtags
    :ensure flycheck-rtags
    :init
    (add-hook 'c-mode-common-hook (lambda ()
                                   (flycheck-select-checker 'rtags)
                                   (setq-local flycheck-highlighting-mode nil)
                                   (setq-local flycheck-check-syntax-automatically nil)))

    (setq rtags-autostart-diagnostics t
          rtags-completions-enabled t)
    (push 'company-rtags company-backends))
#+end_src

Use =cmake-ide= to automate =rtags= processes in a CMake project.
#+begin_src emacs-lisp
  (use-package cmake-ide
    :init (cmake-ide-setup))
#+end_src

** LaTeX
Org will begin replacing pure LaTeX for notes and such, but I still complete homework in here.
First, set up =pdf-tools= for full previews, and disable line numbers in PDF buffers.
#+begin_src emacs-lisp
  (use-package pdf-tools
  :bind
  ("C-c C-g" . pdf-sync-forward-search)

  :init
  (pdf-tools-install)
  (setq mouse-wheel-follow-mouse t
        pdf-view-resize-factor 1.00)
  (add-hook 'pdf-view-mode-hook
            (npg/disable-line-numbers)))
#+end_src

Now, we can setup LaTeX. I don't bother setting up RefTeX because I write papers in Org.
Note, however, that Org also uses these settings to show PDF previews.
#+begin_src emacs-lisp
(use-package tex-site
    :ensure auctex
    :init
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-source-correlate-method 'synctex
          TeX-correlate-start-server t
          TeX-view-program-selection '((output-pdf "pdf-tools"))
          TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
    (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
              #'TeX-revert-document-buffer))
#+end_src

** JSON
=json-mode= works well for all I need, and I have a custom yasnippet for Org. We can pretty-print with =C-c C-f=.
#+begin_src emacs-lisp
  (use-package json-mode)
#+end_src

** Prose
*** =flyspell=
Let's enable spell-checking for text (org, markdown) and commit messages.
#+begin_src emacs-lisp
    (use-package flyspell
      :config
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (add-hook 'gfm-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'git-commit-mode-hook 'flyspell-mode))
#+end_src

*** Dictionary: Webster 1913
I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.
#+begin_src emacs-lisp
    (defun hrs/dictionary-prompt ()
      (read-string
       (format "Word (%s): " (or (hrs/region-or-word) ""))
       nil
       nil
       (hrs/region-or-word)))

    (defun hrs/dictionary-define-word ()
      (interactive)
      (let* ((word (hrs/dictionary-prompt))
             (buffer-name (concat "Definition: " word)))
        (with-output-to-temp-buffer buffer-name
          (shell-command (format "sdcv -n %s" word) buffer-name))))

    (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
#+end_src

*** Thesaurus: WordNet
Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-x s= searches for synonyms.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus)
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
  (define-key global-map "\C-xs" 'synosaurus-lookup)
#+END_SRC

*** Word Count
This little [[https://www.emacswiki.org/emacs/wcMode][minor mode]] sets =mode-line-position= to display character count,
word count, and line count.
#+begin_src emacs-lisp
      (setq mode-line-position
        (append
         mode-line-position
         '((wc-mode
      (6 (:eval (if (use-region-p)
        (format " %d,%d,%d"
          (abs (- (point) (mark)))
          (count-words-region (point) (mark))
          (abs (- (line-number-at-pos (point))
            (line-number-at-pos (mark)))))
            (format " %d,%d,%d"
              (- (point-max) (point-min))
              (count-words-region (point-min) (point-max))
              (line-number-at-pos (point-max))))))
      nil))))
#+end_src

* Terminal
Use =multi-term= for login shell sessions.
#+begin_src emacs-lisp
  (use-package multi-term
    :init
    (global-set-key (kbd "C-c t") 'multi-term)
    (setq multi-term-program-switches "--login"))
#+end_src

Let's not use =evil= in the terminal.
#+begin_src emacs-lisp
  (evil-set-initial-state 'term-mode 'emacs)
#+end_src

* Org
** Installation
 We have already installed the Org package archive, so let's ensure we're using that latest released version with contributions.
 #+begin_src emacs-lisp
   (use-package org
     :ensure org-plus-contrib)
 #+end_src

*** Editor
Indent headings by default, and use =yasnippet=.
#+begin_src emacs-lisp
  (dolist (mode-hook
                   '(org-indent-mode
                     yas-minor-mode))
            (add-hook 'org-mode-hook mode-hook))
#+end_src

Make sure we have LaTeX snippets available in Org mode.
#+begin_src emacs-lisp
  (yas-activate-extra-mode 'latex-mode)
#+end_src

Let's use =ido= in here.
#+begin_src emacs-lisp
  (setq org-completion-use-ido t)
#+end_src

*** Display
Since =nord-theme= doesn't have good heading contrast, use bullet heading indicators.
#+begin_src emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

And change from the distracting default ellipsis.
#+begin_src emacs-lisp
  (setq org-ellipsis " ▼ ")
#+end_src

** Keybindings
Let's add these sensible keybindings.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
  (global-set-key (kbd "C-c a") 'org-agenda)
  (global-set-key (kbd "C-c b") 'org-iswitchb)
#+end_src

Open source block editor (=C-c '=) in a split window; make formats and tabs native.
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'split-window-below)
#+end_src

** Export
*** Oxen
Allow export to markdown and beamer (for presentations).
#+BEGIN_SRC emacs-lisp
  (require 'ox-md)
  (require 'ox-beamer)
#+END_SRC

*** Babel
Don't ask before evaluating code blocks.
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

Allow =babel= to evaluate Emacs lisp, Python, shell, dot, or Gnuplot code.
#+BEGIN_SRC emacs-lisp
  (use-package gnuplot)

  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)
     (dot . t)
     (gnuplot . t)))
#+END_SRC

Allow editing JSON.
#+begin_src emacs-lisp
  (add-to-list 'org-src-lang-modes '("json" . json))
#+end_src

*** HTML
Make sure we have the latest version of =htmlize= installed by default.
#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

Don't include a footer with my contact and publishing information at the bottom
of every exported HTML document.
#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC

Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
which checks the =$BROWSER= environment variable to choose the right browser.
I'd like to always use Firefox, so:
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")

  (setq proess-connection-type nil)
#+END_SRC

** Paths
Store my org files in =~/documents/org=.
#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun npg/org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-index-file (npg/org-file-path "index.org")
        org-jot-file (npg/org-file-path "jot.org")
        org-journal-file (npg/org-file-path "journal.org")
        org-archive-location (concat
                              (npg/org-file-path "archive.org") "::* From %s"))
#+end_src

 Derive the agenda from =index.org=, the project index.
#+begin_src emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+end_src

** Tasks
*** States
I am using these [[http://doc.norang.ca/org-mode.html][task states]], with some verbiage modification. A task should be
in state =WAIT= when the task needs information from someone else; it should be
set to =HOLD= when I don't have time to do it. Note that states =WAIT=,
=HOLD=, and =DROP= request a note upon state shift.
#+begin_src emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|" "DROP(c@/!)" "MEET"))))
#+end_src

#+begin_src emacs-lisp
  (setq org-todo-keyword-faces
        '(("TODO" :foreground "light salmon" :weight bold)
        ("NEXT" :foreground "SteelBlue1" :weight bold)
        ("DONE" :foreground "light green" :weight bold)
        ("WAIT" :foreground "MediumOrchid1" :weight bold)
        ("HOLD" :foreground "Orchid1" :weight bold)
        ("DROP" :foreground "VioletRed1" :weight bold)
        ("MEET" :foreground "light green" :weight bold)))

#+end_src

Since we have defined keys for each state, we can use fast selection with =C-c C-t KEY=.
#+begin_src emacs-lisp
  (setq org-use-fast-todo-selection t)
#+end_src

Using =S-<arrow=, easily change task states without all the processing (e.g. setting timestamps and notes) of normal state cycling. Useful for fixing the status of an entry.
#+begin_src emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

*** Tags
To aid agenda filtering, auto-update tags whenever the state changes.
#+begin_src emacs-lisp
   (setq org-todo-state-tags-triggers
        (quote (("DROP" ("DROP" . t))
                ("WAIT" ("WAIT" . t))
                ("HOLD" ("WAIT") ("HOLD" . t))
                (done ("WAIT") ("HOLD"))
                ("TODO" ("WAIT") ("DROP") ("HOLD"))
                ("NEXT" ("WAIT") ("DROP") ("HOLD"))
                ("DONE" ("WAIT") ("DROP") ("HOLD")))))
#+end_src

*** Archive
Hitting =C-c C-x C-d= will mark a todo as done and move it to an appropriate
place in the archive. Note that this doesn't work in the agenda.
#+BEGIN_SRC emacs-lisp
  (defun npg/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-d") 'npg/mark-done-and-archive)
#+END_SRC

Record the time that a task was archived.
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

** Tags
Note that the =@= group, which contains location tags, functions like a bank of
radio buttons: selecting one location will deselect another selection within the
group. Note that some of the non-exclusive tags are applied by the task state changers.
#+begin_src emacs-lisp
  (setq org-tag-alist '((:startgroup . nil)
                          ("@errand" . ?e)
                          ("@campus" . ?c)
                          ("@home" . ?H)
                          ("@office" . o)
                          (:endgroup . nil)
                          ("DROP" . ?d)
                          ("WAIT" . ?w)
                          ("HOLD" . ?h)
                          ("PERS" . ?P)
                          ("SYS" . ?S)
                          ("LIBRTY" . ?l)
                          ("RSCH" . ?r)
                          ("MUSC" . ?m)))
#+end_src

Since we have defined single keys for tag application, let's use them.
#+begin_src emacs-lisp
  (setq org-fast-tag-selection-single-key (quote expert))
#+end_src

** Capture
Let's bind =org-capture= to something sensible and open it in insert mode.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
  (add-hook 'org-capture-mode-hook 'evil-insert-state)
#+end_src

Define a few common tasks as capture templates.
#+begin_src emacs-lisp
  (setq org-capture-templates
    '(("t" "Todo" entry (file+headline org-index-file "INBOX")
      "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
    ("n" "Next" entry (file+headline org-index-file "INBOX")
      "* NEXT %?\nDEADLINE: %t\n%U\n%a\n" :clock-in t :clock-resume t :immediate-finish t)
    ("m" "Meeting" entry (file+headline org-jot-file)
     "* MEETING: %? :MEETING:\n%U\n" :clock-in t :clock-resume t)
    ("d" "Diversion" entry (file+datetree org-journal-file)
     "* DIVERSION: %? :DIVERSION:\n%U\n" :clock-in t :clock-resume t)
    ("j" "Journal" entry (file+datetree org-journal-file)
     "* %? \n%U\n" :clock-in t :clock-resume t)
    ("j" "Jot" entry (file+headline org-jot-file)
     "* %? :JOT: \n%U\n" :clock-in t :clock-resume t)))
#+end_src

Define some custom actions to take on completion or termination of a capture.
Right now, this just automatically marks for refile any message on which we
successfully complete a capture.
#+begin_src emacs-lisp
  (defun npg/org-capture-after-finalize ()
    (if org-note-abort ()
      (if (equal (npg/buffer-mode) 'mu4e-headers-mode)
           (mu4e-headers-mark-for-refile)
         (if (equal (npg/buffer-mode) 'mu4e-view-mode)
             (mu4e-view-mark-for-refile)))))

  (add-hook 'org-capture-after-finalize-hook 'npg/org-capture-after-finalize)
#+end_src

** Refile
We can refile into the current file and the index file, up to 3 levels deep.
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 3)
                             (org-agenda-files :maxlevel . 3)))
#+end_src

Use full outline paths for refile targets, so ido works well.
#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow =refile= to create parent nodes with confirmation.
#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

** Agenda
I have based this configuration on Gregory Stein's excellent [[https://github.com/gjstein/emacs.d/blob/e725a97a71c6236321f00c705085581f028c1580/config/gs-org.el][agenda configuration]], which it itself based
on Bernt Hansen's [[http://doc.norang.ca/org-mode.html][rather overwhelming guide]].

*** Projects
Here are some project-management helper functions from the sources listed above.
These assume a lazy project definition: any task with a subtask is a project. Note also that stuck projects
are those that do not have a subtask with the =NEXT= designation.

**** =bh=
#+begin_src emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-non-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-task-p)
          nil)
         (t
          next-headline)))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))
#+end_src

**** =gjstein=
#+begin_src emacs-lisp
(defun gs/select-with-tag-function (select-fun-p)
  (save-restriction
    (widen)
    (let ((next-headline
	   (save-excursion (or (outline-next-heading)
			       (point-max)))))
      (if (funcall select-fun-p) nil next-headline))))

(defun gs/select-projects ()
  "Selects tasks which are project headers"
  (gs/select-with-tag-function #'bh/is-project-p))
(defun gs/select-project-tasks ()
  "Skips tags which belong to projects (and is not a project itself)"
  (gs/select-with-tag-function
   #'(lambda () (and
		 (not (bh/is-project-p))
		 (bh/is-project-subtree-p)))))
(defun gs/select-standalone-tasks ()
  "Skips tags which belong to projects. Is neither a project, nor does it blong to a project"
  (gs/select-with-tag-function
   #'(lambda () (and
		 (not (bh/is-project-p))
		 (not (bh/is-project-subtree-p))))))
(defun gs/select-projects-and-standalone-tasks ()
  "Skips tags which are not projects"
  (gs/select-with-tag-function
   #'(lambda () (or
		 (bh/is-project-p)
		 (bh/is-project-subtree-p)))))

(defun gs/org-agenda-project-warning ()
  "Is a project stuck or waiting. If the project is not stuck,
show nothing. However, if it is stuck and waiting on something,
show this warning instead."
  (if (gs/org-agenda-project-is-stuck)
    (if (gs/org-agenda-project-is-waiting) " !W" " !S") ""))

(defun gs/org-agenda-project-is-stuck ()
  "Is a project stuck"
  (if (bh/is-project-p) ; first, check that it's a project
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
	     (has-next))
	(save-excursion
	  (forward-line 1)
	  (while (and (not has-next)
		      (< (point) subtree-end)
		      (re-search-forward "^\\*+ NEXT " subtree-end t))
	    (unless (member "WAITING" (org-get-tags-at))
	      (setq has-next t))))
	(if has-next nil t)) ; signify that this project is stuck
    nil)) ; if it's not a project, return an empty string

(defun gs/org-agenda-project-is-waiting ()
  "Is a project stuck"
  (if (bh/is-project-p) ; first, check that it's a project
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
	(save-excursion
	  (re-search-forward "^\\*+ WAITING" subtree-end t)))
    nil)) ; if it's not a project, return an empty string

;; Some helper functions for agenda views
(defun gs/org-agenda-prefix-string ()
  "Format"
  (let ((path (org-format-outline-path (org-get-outline-path))) ; "breadcrumb" path
	(stuck (gs/org-agenda-project-warning))) ; warning for stuck projects
       (if (> (length path) 0)
	   (concat stuck ; add stuck warning
		   " [" path "]") ; add "breadcrumb"
	 stuck)))

(defun gs/org-agenda-add-location-string ()
  "Gets the value of the LOCATION property"
  (let ((loc (org-entry-get (point) "LOCATION")))
    (if (> (length loc) 0)
	(concat "{" loc "} ")
      "")))
#+end_src

*** Navigation
Use =evil= with Org agendas.
#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda () (evil-org-set-key-theme)))
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+END_SRC

**** Helpers
Jump sections by searching for the chosen section delimiter.
#+begin_src emacs-lisp
  (defun gs/org-agenda-next-section ()
    "Go to the next section in an org agenda buffer"
    (interactive)
    (if (search-forward "===" nil t 1)
        (forward-line 1)
      (goto-char (point-max)))
    (beginning-of-line))

  (defun gs/org-agenda-prev-section ()
    "Go to the next section in an org agenda buffer"
    (interactive)
    (forward-line -2)
    (if (search-forward "===" nil t -1)
        (forward-line 1)
  (goto-char (point-min))))
#+end_src

**** Keys
Quickly view the agenda.
#+begin_src emacs-lisp
  (global-set-key (kbd "<f12>") 'org-agenda)
#+end_src

*** Defaults
**** Views
Bury, do not kill, the agenda buffer on =q=. Also restore windows after we quit.
#+begin_src emacs-lisp
  (setq org-agenda-sticky t)
  (setq org-agenda-restore-windows-after-quit t)
#+end_src

Do not compact the block agenda view -- essential for our custom commands to
show correctly.
#+begin_src emacs-lisp
  (setq org-agenda-compact-blocks nil)
#+end_src

Set the times to display in the time grid.
#+begin_src emacs-lisp
  (setq org-agenda-time-grid
        (quote
         ((daily today remove-match)
          (800 1200 1600 2000)
  "......" "----------------")))
#+end_src

**** Tasks
Make sure that we cannot mark a parent task done when child tasks are still
undone, and dim tasks that are so blocked.
#+begin_src emacs-lisp
  (setq org-enforce-todo-dependencies t)
  (setq org-agenda-dim-blocked-tasks nil)
#+end_src

*** Layout
#+begin_src emacs-lisp
      (setq org-agenda-custom-commands
            '(("h" "Habits" agenda "STYLE=\"habit\""
         ((org-agenda-overriding-header "Habits")
          (org-agenda-sorting-strategy
           '(todo-state-down effort-up category-keep))))
        (" " "Schedule" (
              (agenda "" ((org-agenda-overriding-header "Today's Schedule:")
                    (org-agenda-span 'day)
                    (org-agenda-ndays 1)
                    (org-agenda-start-on-weekday nil)
                    (org-agenda-start-day "+0d")
                    (org-agenda-todo-ignore-deadlines nil)))
              (tags-todo "INBOX"
                    ((org-agenda-overriding-header "Inbox:")
                     (org-tags-match-list-sublevels nil)))
              (tags-todo "-WAIT-HOLD-DROP/!NEXT"
                   ((org-agenda-overriding-header "Next:")))
              (tags-todo "-WAIT-HOLD-DROP/!"
                   ((org-agenda-overriding-header "Active:")
                    (org-agenda-skip-function 'gs/select-projects)))
              (tags "ENDOFAGENDA"
                    ((org-agenda-overriding-header "")
                     (org-tags-match-list-sublevels nil)))
              )
         ((org-agenda-start-with-log-mode t)
          (org-agenda-log-mode-items '(clock))
          (org-agenda-prefix-format '((agenda . "  %-12:c%?-12t %(gs/org-agenda-add-location-string)% s")
                    (timeline . "  % s")
                    (todo . "  %(gs/org-agenda-prefix-string) ")
                    (tags . "  %(gs/org-agenda-prefix-string) ")
                    (search . "  %i %-12:c")))
          (org-agenda-todo-ignore-deadlines 'near)
          (org-agenda-todo-ignore-scheduled t)))

        ("r" "Review" (
              (tags-todo "INBOX"
                    ((org-agenda-overriding-header "Refile:")
                     (org-tags-match-list-sublevels nil)))
              (tags-todo "-WAIT-HOLD-DROP/!NEXT"
                   ((org-agenda-overriding-header "Next Tasks:")))
              (tags-todo "-WAIT-HOLD-DROP/!"
                   ((org-agenda-overriding-header "Active:")
                    (org-agenda-skip-function 'gs/select-projects)))
              (tags-todo "-WAIT-HOLD-DROP-INBOX-STYLE=\"habit\"/!-NEXT"
                   ((org-agenda-overriding-header "Standalone:")
                    (org-agenda-skip-function 'gs/select-standalone-tasks)))
              (tags-todo "-WAIT-HOLD-DROP-INBOX/!-NEXT"
                   ((org-agenda-overriding-header "Remaining:")
                    (org-agenda-skip-function 'gs/select-project-tasks)))
              (tags-todo "-HOLD-DROP/!WAIT"
                   ((org-agenda-overriding-header "Waiting:")))
              (tags-todo "HOLD-DROP/!"
                    ((org-agenda-overriding-header "Holding:")
                     (org-tags-match-list-sublevels nil)))
              (tags "ENDOFAGENDA"
                    ((org-agenda-overriding-header "")
                     (org-tags-match-list-sublevels nil)))
              )
         ((org-agenda-start-with-log-mode t)
          (org-agenda-log-mode-items '(clock))
          (org-agenda-prefix-format '((agenda . "  %-12:c%?-12t %(gs/org-agenda-add-location-string)% s")
                    (timeline . "  % s")
                    (todo . "  %-12:c %(gs/org-agenda-prefix-string) ")
                    (tags . "  %-12:c %(gs/org-agenda-prefix-string) ")
                    (search . "  %i %-12:c")))
          (org-agenda-todo-ignore-deadlines 'near)
          (org-agenda-todo-ignore-scheduled t)))

        ("a" "Agenda" ((agenda "") (alltodo))
         ((org-agenda-ndays 10)
          (org-agenda-start-on-weekday nil)
          (org-agenda-start-day "-1d")
          (org-agenda-start-with-log-mode t)
          (org-agenda-log-mode-items '(closed clock state)))
    )))
#+end_src

*** Post-Processing
Remove empty agenda blocks.
#+begin_src emacs-lisp
  (defun gs/remove-agenda-regions ()
    (save-excursion
      (goto-char (point-min))
      (let ((region-large t))
        (while (and (< (point) (point-max)) region-large)
    (set-mark (point))
    (gs/org-agenda-next-section)
    (if (< (- (region-end) (region-beginning)) 5) (setq region-large nil)
      (if (< (count-lines (region-beginning) (region-end)) 4)
          (delete-region (region-beginning) (region-end)))
      )))))
  (add-hook 'org-agenda-finalize-hook 'gs/remove-agenda-regions)
#+end_src

* Email
** Installation
I will connect =mu4e= to =offlineimap=, which I install in my environment documentation.
#+begin_src emacs-lisp
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
  (require 'mu4e)
#+end_src

I like to think of my mail as living in a Postoffice rather than a Maildir. Perhaps it's just the Brit in me.
#+begin_src emacs-lisp
  (setq mu4e-maildir "~/postoffice")
#+end_src

By officially registering =mu4e= here, we can start a message with =C-x m=.
#+begin_src emacs-lisp
  (setq mail-user-agent 'mu4e-user-agent)
#+end_src

Rather than installing an =offlineimap= timer in =systemctl=, let's have =mu4e= call one-off updates for us by its own timer. I haven't yet investigated the relative performance implications.
#+begin_src emacs-lisp
    (setq mu4e-get-mail-command "offlineimap -o"
          mu4e-update-interval 3600)
#+end_src

Don't ask us about quitting =mu4e=.
#+begin_src emacs-lisp
  (setq mu4e-confirm-quit nil)
#+end_src

** Contexts
See the [[file:~/.offlineimaprc][OfflineIMAP Config]] for inbound mail.

We send all messages by SMTP.
#+begin_src emacs-lisp
  (setq message-send-mail-function 'smtpmail-send-it)
#+end_src

*** Exchange
#+begin_src emacs-lisp
  (let ((exchange-setup-vars '((smtpmail-smtp-server  . "localhost")
                               (smtpmail-smtp-service . 1025)
                               (smtpmail-stream-type  . network)
                               (mu4e-maildir-shortcuts . (("/Exchange/INBOX" . ?i)
                                                          ("/Exchange/Sent" . ?s)
                                                          ("/Exchange/Trash" . ?t)))))
        (exchange-sent-folder "Sent")
        (exchange-trash-folder "Trash")
        (exchange-refile-folder "Archive")
        (exchange-drafts-folder "Drafts"))

      (make-mu4e-context-account
       :name "Exchange"
       :user-mail-address npg/exchange-address
       :sent-folder exchange-sent-folder
       :trash-folder exchange-trash-folder
       :drafts-folder exchange-drafts-folder
       :refile-folder exchange-refile-folder
       :vars exchange-setup-vars))
#+end_src

*** Gmail
#+begin_src emacs-lisp
  (let ((gmail-setup-vars '((smtpmail-smtp-server   . "smtp.gmail.com")
                            (smtpmail-stream-type   . starttls)
                            (smtpmail-smtp-service  .  587)
                            (mu4e-maildir-shortcuts . (("/Gmail/INBOX" . ?i)
                                                       ("/Gmail/[Gmail].Sent Mail"   . ?s)
                                                       ("/Gmail/[Gmail].Trash"       . ?t)))))
        (gmail-prefix "[Gmail].")
        (gmail-sent-folder "Sent Mail")
        (gmail-trash-folder "Trash")
        (gmail-drafts-folder "Drafts"))

      (make-mu4e-context-account
       :name "Gmail"
       :user-mail-address npg/gmail-address
       :sent-folder (concat gmail-prefix gmail-sent-folder)
       :trash-folder (concat gmail-prefix gmail-trash-folder)
       :drafts-folder (concat gmail-prefix gmail-drafts-folder)
       :vars gmail-setup-vars))
#+end_src

** Headers
Open the Exchange inbox with =C-c m=.
#+begin_src emacs-lisp
    (defun npg/visit-inbox ()
      (interactive)
      (mu4e~headers-jump-to-maildir "/Exchange/INBOX"))

    (global-set-key (kbd "C-c m") 'npg/visit-inbox)
#+end_src

Only move messages to the trash folder; do not mark them as deleted.
In other words, do not add =+T= before =-N= so message is not marked IMAP-deleted. See [[https://github.com/djcb/mu/issues/1136][mu #1136]].
#+begin_src emacs-lisp
  (setf (alist-get 'trash mu4e-marks)
        (list :char '("d" . "▼")
              :prompt "dtrash"
              :dyn-target (lambda (target msg)
                            (mu4e-get-trash-folder msg))
              :action (lambda (docid msg target)
                        (mu4e~proc-move docid (mu4e~mark-check-target target) "-N"))))
#+end_src

Optimize display for split window; do not reproduce the subject line within threads.
#+begin_src emacs-lisp
  (setq mu4e-headers-fields
      '( (:human-date     .  25)
         (:flags          .   4)
         (:from           .  22)
         (:thread-subject .  nil)))
#+end_src

Inside the header view, refresh with =o=.
#+begin_src emacs-lisp
    (define-key mu4e-headers-mode-map (kbd "o") 'mu4e-update-mail-and-index)
#+end_src

Quit =mu4e= immediately from header view with =z=.
#+begin_src emacs-lisp
  (define-key mu4e-headers-mode-map (kbd "z") 'mu4e-quit)
#+end_src

** Composition
Auto-fill mode, which automatically inserts hard linebreaks, is quite unhelpful for messages that will be seen on other clients. Let's use soft breaks instead, so we don't drive our non-Emacs friends crazy.
#+begin_src emacs-lisp
  (add-hook 'mu4e-compose-mode-hook (lambda ()
                                 (auto-fill-mode -1)
                                 (visual-line-mode)))
#+end_src

When I'm composing a new email, default to using the first context.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-compose-context-policy 'pick-first)
#+END_SRC

Enable Org-style tables and list manipulation.
#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

Once I've sent a message, kill the associated buffer instead of just burying it.
#+BEGIN_SRC emacs-lisp
  (setq message-kill-buffer-on-exit t)
#+END_SRC

** Replies
So replies quote correctly on other clients, change the reply header string to imitate Gmail.
#+begin_src emacs-lisp
  (defun npg/message-insert-compatible-citation-line ()
    "Based off `message-insert-citation-line`."
    (when message-reply-headers
      (insert "On " (mail-header-date message-reply-headers) " ")
      (insert (mail-header-from message-reply-headers) " wrote...")
      (newline)
      (newline)))

  (setq message-citation-line-function 'npg/message-insert-compatible-citation-line)
#+end_src

** Reader
Display the sender's email address along with their name.
#+BEGIN_SRC emacs-lisp
  (setq mu4e-view-show-addresses t)
#+END_SRC

While HTML emails are undeniably sinful, we often have to read them. That's
sometimes best done in a browser. This effectively binds =a h= to open the
current email in my default Web browser.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'mu4e-view-actions '("html in browser" . mu4e-action-view-in-browser) t)
#+END_SRC

** Signatures
These are my plain-text email signatures.
#+begin_src emacs-lisp
    (defvar npg/email-signatures)
    (setq npg/email-signatures '(("formal" . (concat
                                              "Nathanael Gentry\n"
                                              "Mathematics, Liberty University\n"
                                              "Class of 2021\n"))
                                 ("personal" . "Nathanael Gentry\n")))
#+end_src

Thanks to Rob Stewart for the =mu4e-read-option= idea.
#+begin_src emacs-lisp
    (defun npg/mu4e-choose-signature ()
      "Insert one of a number of sigs"
      (interactive)
      (let ((message-signature
             (mu4e-read-option "Signature:"
                               npg/email-signatures)))
        (message-insert-signature)))

    (add-hook 'mu4e-compose-mode-hook
              (lambda () (local-set-key (kbd "C-c C-w") #'npg/mu4e-choose-signature)))
#+end_src

** Notifications
We use the =mu4e-alert= package to give modeline mail alerts.
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :after mu4e
    :init
    (setq mu4e-alert-interesting-mail-query
          (concat
           "flag:unread maildir:/Exchange/INBOX "
           "OR "
           "flag:unread maildir:/Gmail/INBOX"))
    (mu4e-alert-enable-mode-line-display)

    (defun npg/refresh-mu4e-alert-mode-line ()
      (interactive)
      (mu4e-alert-enable-mode-line-display))

    (run-with-timer 0 3600 'npg/refresh-mu4e-alert-mode-line))
#+end_src

** Org
If we capture a todo while in =mu4e= header mode, store a link to the message itself, not the header query.

As noted at [[http://pragmaticemacs.com/emacs/master-your-inbox-with-mu4e-and-org-mode/][Pragmatic Emacs]], this allows creating a todo for messages that need action, and then archiving it since it no longer needs to stay in the inbox -- we have a direct link to it in the todo.
#+begin_src emacs-lisp
  (require 'org-mu4e)
  (setq org-mu4e-link-query-in-headers-mode nil)
#+end_src

