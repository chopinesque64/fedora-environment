#+TITLE: Emacs Configuration
#+AUTHOR: Nathanael Gentry
#+EMAIL: ngentry1@liberty.edu
#+OPTIONS: toc:nil num:nil

* Bootstrap
My =init.el= sets up MELPA in the package manager and installs =use-package.el= so all the configuration here works, even on a new install. Here, we make this happen by ensuring packages are installed before we use them.
#+begin_src emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+end_src

Start Emacs maximized.
#+begin_src emacs-lisp
  (toggle-frame-maximized)
#+end_src

Tell emacs where our linux configuration document lives.
#+begin_src emacs-lisp
  (setq linux-configuration-directory "~/projects/fedora-environment/")
#+end_src

Add a temporary customization file.
#+begin_src emacs-lisp
  (setq custom-file (make-temp-file "emacs-custom"))
#+end_src

* Sensible Defaults
Use HRS's [[https://github.com/hrs/sensible-defaults.el/][sensible-defaults.el]] for common-sense settings.
#+begin_src emacs-lisp
  (require 'url)
  (setq-local sensible-defaults-loc (concat user-emacs-directory "defaults.el"))
  (if (not (file-exists-p sensible-defaults-loc))
      (url-copy-file "https://raw.githubusercontent.com/hrs/sensible-defaults.el/master/sensible-defaults.el" sensible-defaults-loc))

  (load-file sensible-defaults-loc)
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src

** Sensible Functions
Define some sensible utility functions.

#+begin_src emacs-lisp
  (defun npg/append-to-path (path)
    "Append a path to $PATH and exec-path"
    (setenv "PATH" (concat (getenv "PATH") ":" path))
    (add-to-list 'exec-path path))
#+end_src

#+begin_src emacs-lisp
  (defun npg/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))
#+end_src

* Custom Functions
** Peek Frame
Tuhdo has an excellent tutorial on setting up popup frames for =rtags=, and I've generalized his code and made the popup undecorated but still resizable.

#+begin_src emacs-lisp :tangle yes
  (defun npg/make-peek-frame (in-frame-function &rest args)
    "Make a new frame for peeking definition"
    (let (summary
          doc-frame
          x y
          ;; Find the pixel absolute position of the current beginning of the symbol at point.
          (abs-pixel-pos (save-excursion
                           (beginning-of-thing 'symbol)
                           (window-absolute-pixel-position))))
      (setq x (car abs-pixel-pos))
      (setq y (+ (cdr abs-pixel-pos) (frame-char-height)))

      ;; 2. Create a new invisible frame, with the current buffer in it.
      (setq doc-frame (make-frame '((minibuffer . nil)
                                    (name . "*Peek*")
                                    (width . 80)
                                    (visibility . nil)
                                    (height . 15)
                                    (undecorated . t)
                                    (drag-internal-border . 1)
                                    (internal-border-width . 5))))

      ;; 3. Position the new frame right under the beginning of the symbol at point.
      (set-frame-position doc-frame x y)

      ;; 4. Jump to the symbol at point.
      (with-selected-frame doc-frame
        (apply in-frame-function args)
        (read-only-mode)
        (when semantic-stickyfunc-mode (semantic-stickyfunc-mode -1))
        (recenter-top-bottom 0))

      ;; 5. Make frame visible again
      (make-frame-visible doc-frame)))
#+end_src

* Appearance
** Decorations
Reclaim real estate, especially on my old X220T, by disabling window chrome.
#+begin_src emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode -1)
#+end_src

** Theme
I love the unobtrusive elegance of [[https://github.com/arcticicestudio/nord-emacs][nord-emacs]], although sometimes the colors can be a little /too/ subtle.
#+begin_src emacs-lisp
  (use-package nord-theme
    :load-path "themes"
    :config
    (load-theme 'nord t))
#+end_src

Frame transparency does not seem to play nicely with Cinnamon, but here's a function to manipulate it.
#+begin_src emacs-lisp
  (defun opacity (value)
    "Sets the percent opacity of the frame window."
    (interactive "nOpacity Value (0 - 100):")
    (set-frame-parameter (selected-frame) 'alpha value))
#+end_src

** Modeline
I want a pristine modeline, uncluttered by modetexts. Note that the window title gives =projectile= info.
#+begin_src emacs-lisp
  (use-package minions
    :config
    (setq minions-mode-line-lighter ""
          minions-mode-line-delimiters '("" . ""))
    (minions-mode 1))
#+end_src

Now, let's display 24-hour time in the modeline, but hide the default system
load information.
#+begin_src emacs-lisp
  (setq display-time-default-load-average nil
        display-time-24hr-format t)

  (display-time-mode)
#+end_src

** Default Windows
Split into two windows on startup.
#+begin_src emacs-lisp
  (split-window-right)
#+end_src

* Global Editor
Note that =sensible-defaults.el= already inhibits the startup screen and blanks the scratch buffer.

** Tabs & Indentation
Let's make our shallow tabs into spaces.
#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default indent-tabs-mode nil)
#+end_src

** Lines
Give yourself the comfort of context, even if it gobbles some real estate.
#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
#+end_src

Also show column numbers in the modeline
#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

Who needs to split lines at 80 characters?
#+begin_src emacs-lisp
  (global-visual-line-mode)
#+end_src

** =smartparens=
So powerful.
#+begin_src emacs-lisp
(use-package smartparens
  :bind (:map smartparens-mode-map
         ("C-M-f" . sp-next-sexp)
         ("C-M-b" . sp-backward-sexp)
         ("C-M-d" . sp-down-sexp)
         ("C-M-a" . sp-backward-down-sexp)
         ("C-M-u" . sp-up-sexp)
         ("C-M-e" . sp-backward-up-sexp)
         ("C-M-n" . sp-forward-sexp)
         ("C-M-p" . sp-previous-sexp)
         ("C-S-d" . sp-beginning-of-sexp)
         ("C-S-a" . sp-end-of-sexp)
         ("C-M-k" . sp-kill-sexp)
         ("C-M-w" . sp-copy-sexp)
         ("M-<delete>" . sp-unwrap-sexp)
         ("M-<backspace>" . sp-backward-unwrap-sexp)
         ("M-D" . sp-splice-sexp)
         ("C-S-<backspace>" . sp-splice-sexp-killing-around)
         ("C-<right>" . sp-forward-slurp-sexp)
         ("C-<left>" . sp-forward-barf-sexp)
         ("C-S-<left>" . sp-backward-slurp-sexp)
         ("C-S-<right>" . sp-backward-barf-sexp))
  :init
  (setq sp-cancel-autoskip-on-backward-movement nil)
  :config
(require 'smartparens-config))
#+end_src

** =rainbow-delimiters=
I am not yet an Emacs minimalist.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :init (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

** =ido=
Very basic for now.

#+begin_src emacs-lisp
  (ido-mode 'both)
  (setq ido-enable-flex-matching t)

  ; Use the current window when visiting files and buffers with ido
  (setq ido-default-file-method 'selected-window)
  (setq ido-default-buffer-method 'selected-window)

  ; Use the current window for indirect buffer display
  (setq org-indirect-buffer-display 'current-window)
#+end_src

** =company=
Enable =company= everywhere, and reward our laziness by giving ourselves access to unicode math.
#+begin_src emacs-lisp
  (use-package company
    :ensure company-math
    :init (global-company-mode 1)
    :config (add-to-list 'company-backends 'company-math-symbols-unicode))
#+end_src

Bind =M-/= to bring up a completion menu.
#+begin_src emacs-lisp
  (global-set-key (kbd "M-/") 'company-complete-common)
#+end_src

Quickhelp is useful for API discovery, but it doesn't talk to =nord-theme= right now.
#+begin_src emacs-lisp
  (use-package company-quickhelp
    :init (company-quickhelp-mode))
#+end_src

** =flycheck=
We'll add local mode hooks for flycheck.
#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

** Keybindings
Quickly open my Emacs and Fedora configuration org documents.

#+begin_src emacs-lisp
  (defun npg/visit-emacs-config ()
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (global-set-key (kbd "C-c e e") 'npg/visit-emacs-config)
#+end_src

#+begin_src emacs-lisp
  (defun npg/visit-linux-config ()
    (interactive)
    (find-file (concat linux-configuration-directory "fedora-environment.org")))

    (global-set-key (kbd "C-c e f") 'npg/visit-linux-config)
#+end_src

Always kill the current buffer with keystroke.

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-x k") 'npg/kill-current-buffer)
#+end_src

When splitting a window, I always want focus in the new window.

#+BEGIN_SRC emacs-lisp
  (defun nps/split-window-below-and-switch ()
    "Split the window horizontally, then switch to the new pane."
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))

  (defun npg/split-window-right-and-switch ()
    "Split the window vertically, then switch to the new pane."
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'npg/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'npg/split-window-right-and-switch)
#+END_SRC

* Project Management
** =ag=
Try out the Silver Searcher.
#+begin_src emacs-lisp
  (use-package ag)
#+end_src

** =magit=
Nothing special to see here.
#+begin_src emacs-lisp
  (use-package magit
    :bind
    ("C-x g" . magit-status)

    :config
    (setq magit-completing-read-function 'magit-ido-completing-read))
#+end_src

** =projectile=
   #+begin_src emacs-lisp
     (use-package projectile)
   #+end_src

* Development Environments
And to think of the untold hours I spent configuring C\C++ tags when I could have used this!

#+begin_src emacs-lisp
  (use-package dumb-jump
    :config
    (global-set-key (kbd "M-.") 'dumb-jump-go))
#+end_src

** Python
Set up our =virtualenv= for =jedi=.

#+begin_src emacs-lisp
  (npg/append-to-path "~/.local/bin")
#+end_src

Use =elpy= for a great IDE experience.

#+begin_src emacs-lisp
  (use-package elpy
    :init (elpy-enable))
#+end_src

Check syntax with =flycheck=.

#+begin_src emacs-lisp
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+end_src

Format code by PEP8 on save.

#+begin_src emacs-lisp
  (use-package py-autopep8
  :init (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src

(Do we need to use company-jedi since we already have elpy?)

** C/C++
Maybe =rtags= is a bit intense, but using it with =cmake-ide= works well now.

#+begin_src emacs-lisp
  (use-package rtags
    :ensure flycheck-rtags
    :init
    (add-hook 'c-mode-common-hook (lambda ()
                                   (flycheck-select-checker 'rtags)
                                   (setq-local flycheck-highlighting-mode nil)
                                   (setq-local flycheck-check-syntax-automatically nil)))

    (setq rtags-autostart-diagnostics t
          rtags-completions-enabled t)
    (push 'company-rtags company-backends))
#+end_src

Use =cmake-ide= to automate =rtags= processes in a CMake project.

#+begin_src emacs-lisp
  (use-package cmake-ide
    :init (cmake-ide-setup))
#+end_src

** LaTeX
Org will begin replacing pure LaTeX for notes and such, but I still complete homework in here.

First, set up =pdf-tools= for full previews, and disable line numbers in PDF buffers.
#+begin_src emacs-lisp
  (use-package pdf-tools
  :bind
  ("C-c C-g" . pdf-sync-forward-search)

  :init
  (pdf-tools-install)
  (setq mouse-wheel-follow-mouse t
        pdf-view-resize-factor 1.00)
  (add-hook 'pdf-view-mode-hook
            (lambda() (display-line-numbers-mode -1))))
#+end_src

Now, we can setup LaTeX. I don't bother setting up RefTeX because I write papers in Org.
Note, however, that Org also uses these settings to show PDF previews.
#+begin_src emacs-lisp
(use-package tex-site
    :ensure auctex
    :init
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-source-correlate-method 'synctex
          TeX-correlate-start-server t
          TeX-view-program-selection '((output-pdf "pdf-tools"))
          TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))
    (add-hook 'TeX-after-TeX-LaTeX-command-finished-hook
              #'TeX-revert-document-buffer))
#+end_src

** Prose
*** =flyspell=
Let's enable spell-checking for text (org, markdown) and commit messages.
#+begin_src emacs-lisp
    (use-package flyspell
      :config
      (add-hook 'text-mode-hook 'turn-on-auto-fill)
      (add-hook 'gfm-mode-hook 'flyspell-mode)
      (add-hook 'org-mode-hook 'flyspell-mode)
      (add-hook 'git-commit-mode-hook 'flyspell-mode))
#+end_src

*** Dictionary: Webster 1913
I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
so these definitions are a lot of fun.
#+begin_src emacs-lisp
    (defun hrs/dictionary-prompt ()
      (read-string
       (format "Word (%s): " (or (hrs/region-or-word) ""))
       nil
       nil
       (hrs/region-or-word)))

    (defun hrs/dictionary-define-word ()
      (interactive)
      (let* ((word (hrs/dictionary-prompt))
             (buffer-name (concat "Definition: " word)))
        (with-output-to-temp-buffer buffer-name
          (shell-command (format "sdcv -n %s" word) buffer-name))))

    (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
#+end_src

*** Thesaurus: WordNet
Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
=C-x s= searches for synonyms.

#+BEGIN_SRC emacs-lisp
  (use-package synosaurus)
  (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
  (add-hook 'after-init-hook #'synosaurus-mode)
  (define-key global-map "\C-xs" 'synosaurus-lookup)
#+END_SRC

* Terminal
Use =multi-term= for login shell sessions.

#+begin_src emacs-lisp
  (use-package multi-term
    :init
    (global-set-key (kbd "C-c t") 'multi-term)
    (setq multi-term-program-switches "--login"))
#+end_src

Line numbers don't play well with my =zsh= completion, so let's disable them.

#+begin_src emacs-lisp
  (add-hook 'term-mode-hook
            (lambda () (display-line-numbers-mode -1)))
#+end_src
* Org
 We have already installed the Org package archive, so let's ensure we're using that latest released version with contributions.
 #+begin_src emacs-lisp
   (use-package org
     :ensure org-plus-contrib)
 #+end_src

** Defaults
Indent headings by default, and use =yasnippet=.
#+begin_src emacs-lisp
  (dolist (mode-hook
                   '(org-indent-mode
                     yas-minor-mode))
            (add-hook 'org-mode-hook mode-hook))
#+end_src

Make sure we have LaTeX snippets available in Org mode.
#+begin_src emacs-lisp
  (yas-activate-extra-mode 'latex-mode)
#+end_src

Let's use =ido= in here.
#+begin_src emacs-lisp
  (setq org-completion-use-ido t)
#+end_src

Open source block editor (=C-c '=) in a split window; make formats and tabs native.
#+begin_src emacs-lisp
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-window-setup 'split-window-below)
#+end_src

Since =nord-theme= doesn't have good heading contrast, use bullet heading indicators.
#+begin_src emacs-lisp
  (use-package org-bullets
    :init (add-hook 'org-mode-hook 'org-bullets-mode))
#+end_src

And change from the distracting default ellipsis.
#+begin_src emacs-lisp
  (setq org-ellipsis " â–¼ ")
#+end_src

** Paths
Store my org files in =~/documents/org=, and derive an agenda from all files stored therein.
#+begin_src emacs-lisp
  (setq org-directory "~/documents/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-agenda-files (list (file-name-as-directory org-directory)))
  (setq org-capture-file (org-file-path "capture.org"))
#+end_src

** Tasks
I am using these [[http://doc.norang.ca/org-mode.html][task states]], with some verbiage modification. A task should be in state =WAIT= when the task needs information from someone else; it should be set to =HOLD= when I don't have time to do it.
#+begin_src emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAIT(w@/!)" "HOLD(h@/!)" "|" "DROP(c@/!)" "MEET"))))
#+end_src

Since we have defined keys for each state, we can use fast selection with =C-c C-t KEY=.
#+begin_src emacs-lisp
  (setq org-use-fast-todo-selection t)
#+end_src

Using =S-<arrow>=, easily change todo states without all the processing (e.g. setting timestamps and notes) of normal state cycling. Useful for fixing the status of an entry.
#+begin_src emacs-lisp
  (setq org-treat-S-cursor-todo-selection-as-state-change nil)
#+end_src

To aid agenda filtering, auto-update tags whenever the state changes.
#+begin_src emacs-lisp
   (setq org-todo-state-tags-triggers
        (quote (("DROP" ("DROP" . t))
                ("WAIT" ("WAIT" . t))
                ("HOLD" ("WAIT") ("HOLD" . t))
                (done ("WAIT") ("HOLD"))
                ("TODO" ("WAIT") ("DROP") ("HOLD"))
                ("NEXT" ("WAIT") ("DROP") ("HOLD"))
                ("DONE" ("WAIT") ("DROP") ("HOLD")))))
#+end_src

Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
place in the archive.
#+BEGIN_SRC emacs-lisp
  (defun hrs/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
#+END_SRC

Record the time that a todo was archived.
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC

** Projects
Here are some helper functions, from [[http://doc.norang.ca/org-mode.html#Projects][norang]], that the agenda uses for project
display. These assume a lazy project definition: any task with a subtask is a
project. Note also that stuck projects are those that do not have a subtask with
the =NEXT= designation.
#+begin_src emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-non-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-task-p)
          nil)
         (t
          next-headline)))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))
#+end_src

** Capture
Let's bind =org-capture= to something sensible.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

Define a few common tasks as capture templates. Specifically, I frequently:
  - Maintain a todo list

#+begin_src emacs-lisp
  (setq org-capture-templates
        (quote (("t" "todo" entry (file org-capture-file)
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t))))
#+end_src

** Refile
We can refile into this file and any agenda file, up to 3 levels deep.
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 3)
                             (org-agenda-files :maxlevel . 3)))
#+end_src

Use full outline paths for refile targets, so ido works well.
#+begin_src emacs-lisp
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
#+end_src

Allow refile to create parent nodes with confirmation
#+begin_src emacs-lisp
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+end_src

#+begin_src emacs-lisp
#+end_src


#+end_src


